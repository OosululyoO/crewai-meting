

=== ai_meeting_assistant/pyproject.toml ===
[project]
name = "ai_meeting_assistant"
version = "0.1.0"
description = "ai_meeting_assistant using crewAI"
authors = [{ name = "Your Name", email = "you@example.com" }]
requires-python = ">=3.10,<3.14"
dependencies = [
    "crewai[tools]>=0.140.0,<1.0.0",
    "langchain-openai>=0.1.0",
    "langchain-google-genai>=1.0.0",
    "python-dotenv>=1.0.0",
    "pyyaml>=6.0.0",
    "python-docx>=0.8.11",
    "PyPDF2>=3.0.1",
    "pandas>=2.2.0",
    "openpyxl>=3.1.2",

]

[project.scripts]
ai_meeting_assistant = "ai_meeting_assistant.main:run"
run_crew = "ai_meeting_assistant.main:run"
train = "ai_meeting_assistant.main:train"
replay = "ai_meeting_assistant.main:replay"
test = "ai_meeting_assistant.main:test"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.crewai]
type = "crew"


=== ai_meeting_assistant/README.md ===
# AiMeetingAssistant Crew

Welcome to the AiMeetingAssistant Crew project, powered by [crewAI](https://crewai.com). This template is designed to help you set up a multi-agent AI system with ease, leveraging the powerful and flexible framework provided by crewAI. Our goal is to enable your agents to collaborate effectively on complex tasks, maximizing their collective intelligence and capabilities.

## Installation

Ensure you have Python >=3.10 <3.14 installed on your system. This project uses [UV](https://docs.astral.sh/uv/) for dependency management and package handling, offering a seamless setup and execution experience.

First, if you haven't already, install uv:

```bash
pip install uv
```

Next, navigate to your project directory and install the dependencies:

(Optional) Lock the dependencies and install them by using the CLI command:
```bash
crewai install
```
### Customizing

**Add your `OPENAI_API_KEY` into the `.env` file**

- Modify `src/ai_meeting_assistant/config/agents.yaml` to define your agents
- Modify `src/ai_meeting_assistant/config/tasks.yaml` to define your tasks
- Modify `src/ai_meeting_assistant/crew.py` to add your own logic, tools and specific args
- Modify `src/ai_meeting_assistant/main.py` to add custom inputs for your agents and tasks

## Running the Project

To kickstart your crew of AI agents and begin task execution, run this from the root folder of your project:

```bash
$ crewai run
```

This command initializes the ai_meeting_assistant Crew, assembling the agents and assigning them tasks as defined in your configuration.

This example, unmodified, will run the create a `report.md` file with the output of a research on LLMs in the root folder.

## Understanding Your Crew

The ai_meeting_assistant Crew is composed of multiple AI agents, each with unique roles, goals, and tools. These agents collaborate on a series of tasks, defined in `config/tasks.yaml`, leveraging their collective skills to achieve complex objectives. The `config/agents.yaml` file outlines the capabilities and configurations of each agent in your crew.

## Support

For support, questions, or feedback regarding the AiMeetingAssistant Crew or crewAI.
- Visit our [documentation](https://docs.crewai.com)
- Reach out to us through our [GitHub repository](https://github.com/joaomdmoura/crewai)
- [Join our Discord](https://discord.com/invite/X4JWnZnxPb)
- [Chat with our docs](https://chatg.pt/DWjSBZn)

Let's create wonders together with the power and simplicity of crewAI.


=== ai_meeting_assistant/.gitignore ===
.env
__pycache__/
.DS_Store


=== ai_meeting_assistant/.env ===
MODEL=gpt-4o
OPENAI_API_KEY=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
GOOGLE_API_KEY=AIzaSyDZDDvhc5-iRdv_vNdM9_1fAmvKDVBoRVY
SERPER_API_KEY=673e7b9ba21c606af2d261fd44a5d269057a0a5a


=== ai_meeting_assistant/all_code.py ===
import os
import datetime

# 設定根目錄（你要輸出的資料夾）
root_folder = './'  # ← 請改成你自己的資料夾路徑
output_file = 'all_code.txt'
output_file = f"{datetime.datetime.now().strftime('%Y%m%d_%H%M')}_{output_file}"

# 設定輸出資料夾
output_folder = './coderocord/'
os.makedirs(output_folder, exist_ok=True)
output_file = os.path.join(output_folder, output_file)

def prompt_user(path):
    rel_path = os.path.relpath(path, root_folder)
    while True:
        choice = input(f"是否要輸出 '{rel_path}' 的內容？(Y/N): ").strip().upper()
        if choice in ['Y', 'N']:
            return choice == 'Y'
        print("請輸入 Y 或 N。")

with open(output_file, 'w', encoding='utf-8') as out:
    for name in os.listdir(root_folder):
        full_path = os.path.join(root_folder, name)

        if prompt_user(full_path):
            if os.path.isfile(full_path):
                try:
                    with open(full_path, 'r', encoding='utf-8') as f:
                        out.write(f"\n\n=== {name} ===\n")
                        out.write(f.read())
                except Exception as e:
                    out.write(f"\n\n=== {name} ===\n")
                    out.write(f"[無法讀取此檔案: {e}]\n")

            elif os.path.isdir(full_path):
                for foldername, _, filenames in os.walk(full_path):
                    for filename in filenames:
                        file_path = os.path.join(foldername, filename)
                        rel = os.path.relpath(file_path, root_folder)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                out.write(f"\n\n=== {rel} ===\n")
                                out.write(f.read())
                        except Exception as e:
                            out.write(f"\n\n=== {rel} ===\n")
                            out.write(f"[無法讀取此檔案: {e}]\n")

print(f"\n✅ 輸出完成，請查看 {output_file}")


=== ai_meeting_assistant/coderocord/20250717_1643_all_code.txt ===


=== ai_meeting_assistant/saved_chats/逃漏稅囉.json ===
{
  "meeting_name": "逃漏稅囉",
  "chat_history": [
    {
      "user": "我該怎麼避免逃漏稅發生？",
      "agent": "user",
      "reply": ""
    },
    {
      "user": "我該怎麼避免逃漏稅發生？",
      "agent": "會計師",
      "reply": "避免逃漏稅的發生需要從多個方面著手。首先，確保所有的收入和支出都被正確地記錄和報告。這意味著需要保持良好的會計紀錄，並定期審核這些紀錄以確保其準確性。其次，了解並遵守當地的稅務法規是至關重要的，這樣可以避免因不熟悉法律而無意中違反規定。第三，考慮聘請專業的會計師或稅務顧問，他們可以提供專業的建議和指導，幫助確保所有的稅務申報都符合規定。此外，定期參加稅務培訓或研討會以更新自己的稅務知識也是一個不錯的做法。最後，誠實和透明是避免逃漏稅的關鍵，確保所有的財務活動都是合法和合規的。```"
    },
    {
      "user": "你的想法是什麼？",
      "agent": "user",
      "reply": ""
    },
    {
      "user": "你的想法是什麼？",
      "agent": "律師",
      "reply": "作為律師，我同意會計師提供的建議，並補充一些法律層面的意見。首先，企業應制定並實施嚴格的內部控制制度，以確保所有財務交易的合法性和透明性。其次，應定期進行內部或外部審計，以識別和糾正可能的合規問題。此外，企業應確保所有相關人員，包括管理層和員工，接受必要的法律和稅務培訓，以提高他們的合規意識和能力。最後，企業應與法律顧問保持密切聯繫，以便在遇到複雜的法律問題時及時獲得專業建議，確保所有行為都符合法律規定。這些措施將有助於降低逃漏稅風險，並增強企業的法律合規性。"
    }
  ],
  "role1_cfg": {
    "name": "會計師",
    "backstory": "擁有豐富稅務與財務管理經驗的會計師",
    "task": "從財務與稅務角度提供建議"
  },
  "role2_cfg": {
    "name": "律師",
    "backstory": "熟悉商業合規與公司法的律師",
    "task": "從法律角度分析問題並提供建議"
  }
}

=== ai_meeting_assistant/saved_chats/補助案討論.json ===
{
  "meeting_name": "補助案討論",
  "chat_history": [
    {
      "user": "你對這個補助案的看法是什麼？",
      "agent": "user",
      "reply": ""
    },
    {
      "user": "你對這個補助案的看法是什麼？",
      "agent": "理事",
      "reply": "這個補助案旨在促進友善工作環境，並與民間團體合作推動工作場所性騷擾防治。申請單位需具備相關議題的長期關注，並在申請時提供詳細的計畫書和預算。補助金額最高可達計畫總經費的95%，但不超過新臺幣25萬元。審查過程注重計畫的完整性和可行性，並優先考慮特定地區的計畫。申請單位需遵循財務管理規範，並確保報告的真實性。總體而言，這是促進安全工作環境的良好機會，但需謹慎計畫和執行以確保合規和最大化效益。"
    },
    {
      "user": "請簡單的規劃執行方向",
      "agent": "user",
      "reply": ""
    },
    {
      "user": "請簡單的規劃執行方向",
      "agent": "理事",
      "reply": "根據提供的補助指引和背景，以下是一個簡單的執行計劃，用於申請和實施工作場所性騷擾防治宣導活動：\n\n1. **確定目標和受眾：**\n   - 明確定義項目的目的，專注於促進友善的工作環境和防止工作場所性騷擾。\n   - 確定宣導活動的目標受眾和地區，優先考慮彰化、南投、雲林、嘉義、台南、高雄、屏東、台東、花蓮、連江、金門和澎湖等地，因為這些地區是優先補助對象。\n\n2. **制定詳細計劃：**\n   - 創建詳細的項目計劃，包括項目名稱、目標、具體活動（如研習會、專題講座和培訓課程）、時間表和預期成果。\n   - 概述執行項目的策略和方法，確保其可行性並符合補助要求。\n\n3. **預算規劃：**\n   - 準備詳細的預算，遵循資金指引，涵蓋講座鐘點費、專家學者交通與住宿費、場地租賃和材料等合格支出。\n   - 確保預算不超過計畫總經費的95%或新台幣25萬元的最高補助限額。\n\n4. **準備申請文件：**\n   - 收集所有必要文件，包括申請書、實施計畫書、經費概算表和組織合法設立的證明。\n   - 確保所有文件完整並在申請期限內提交，以避免資格被取消。\n\n5. **實施和監控：**\n   - 根據核准的計畫執行項目，保持所有活動和財務交易的透明度和問責性。\n   - 監控宣導活動的進展和效果，根據需要進行調整以達成預期成果。\n\n6. **報告和評估：**\n   - 項目完成後，準備一份詳細的報告，說明所進行的活動、達成的成果和財務支出。\n   - 在指定的截止日期前，提交所有所需文件以進行財務驗證和最終報告給勞動部。\n\n7. **合規和跟進：**\n   - 確保遵守補助中列出的所有規定和指引，包括適當的文件和財務管理。\n   - 保留所有記錄和文件至少五年，以備勞動部可能的審計和評估。\n\n通過遵循這一結構化的方法，組織可以有效地計劃、執行和報告工作場所性騷擾防治宣導活動，最大化影響並確保符合補助要求。"
    },
    {
      "user": "你覺得可以舉辦哪些活動？",
      "agent": "user",
      "reply": ""
    },
    {
      "user": "你覺得可以舉辦哪些活動？",
      "agent": "理事",
      "reply": "根據勞動部的補助指引，我們可以設計一些活動來推動工作場所性騷擾防治宣導。以下是一些建議的活動類型：\n\n1. **研習會和專題講座：**\n   - 邀請專家學者進行工作場所性騷擾防治的專題演講，分享最新的研究成果和實務經驗。\n   - 針對不同職業群體設計專門的研習會，提供具體的防治策略和案例分析。\n\n2. **教育訓練：**\n   - 為企業管理層和人力資源部門提供專業的性騷擾防治培訓，強化他們的應對能力。\n   - 開展員工教育課程，提高全體員工對性騷擾的認識和防範意識。\n\n3. **宣導活動：**\n   - 在企業內部或公共場所舉辦宣導活動，如展覽、海報展示和互動工作坊，提升大眾對性騷擾問題的關注。\n   - 利用社交媒體平台進行線上宣導，擴大影響範圍。\n\n4. **被害人保護及扶助措施：**\n   - 設立專線或諮詢服務，為性騷擾受害者提供法律和心理支持。\n   - 舉辦支持小組會議，為受害者提供一個安全的分享和支持空間。\n\n5. **其他創新活動：**\n   - 開展角色扮演或模擬場景活動，讓參與者親身體驗和理解性騷擾的影響。\n   - 與當地社區或學校合作，舉辦性別平等和防治性騷擾的教育活動，從源頭上提高認識。\n\n這些活動不僅能夠提高公眾對性騷擾問題的認識，還能促進友善和安全的工作環境的建立。通過多元化的活動形式，我們可以更有效地傳達性騷擾防治的重要性。"
    },
    {
      "user": "提供一點建議",
      "agent": "user",
      "reply": ""
    },
    {
      "user": "提供一點建議",
      "agent": "監事",
      "reply": "根據提供的補助案資訊和執行計劃，我建議以下幾點以進一步完善計劃：\n\n1. **強化合作夥伴關係：**\n   - 與當地的非政府組織、社區團體或學術機構建立合作關係，這不僅能夠擴大活動的影響力，還能獲得更多的資源和支持。\n\n2. **評估與調整機制：**\n   - 在活動進行中設置定期的評估機制，收集參與者的反饋和建議，以便及時調整活動內容和方式，確保活動的有效性和參與度。\n\n3. **創新宣導方式：**\n   - 除了傳統的研習會和講座，考慮使用數位媒體和互動技術，如線上研討會、虛擬實境體驗等，吸引更多年輕族群的參與。\n\n4. **長期影響追蹤：**\n   - 設立長期的影響追蹤機制，評估活動對工作場所性騷擾防治的實際效果，並根據結果進行後續計劃的調整和優化。\n\n5. **資源管理與透明度：**\n   - 確保所有活動的資源管理透明，並定期向相關利益相關者報告進展和成果，以增強信任和支持。\n\n透過這些建議，申請單位可以更有效地推動工作場所性騷擾防治活動，並確保計劃的長期成功和可持續性。"
    }
  ],
  "role1_cfg": {
    "name": "理事",
    "backstory": "你是在NGO服務多年，經驗豐富、邏輯強大、能力強大的理事，協助業務的執行運作",
    "task": "思考如何執行計劃，給出方法與建議，並提供執行的方針。回應提問與問題。請用繁體中文回答問題。"
  },
  "role2_cfg": {
    "name": "監事",
    "backstory": "你是一位充滿專業素養的監事，提供執行方法與建議，善用批判思考與哲學思辨，協助完善計劃的運行並找出需要改進的地方",
    "task": "尋找改進或是可以更加完善的地方，給予建議。請用繁體中文回答問題。"
  }
}

=== ai_meeting_assistant/saved_chats/小學教室.json ===
{
  "meeting_name": "小學教室",
  "chat_history": [
    {
      "user": "出一題數學題目",
      "agent": "user",
      "reply": ""
    },
    {
      "user": "出一題數學題目",
      "agent": "老師",
      "reply": "好的，這是一道數學題目給你練習：如果一個籃子裡有15個蘋果，然後你又放進去7個蘋果，最後拿走4個蘋果，籃子裡還剩下多少個蘋果呢？請試著計算一下，然後告訴我你的答案。"
    },
    {
      "user": "請回答",
      "agent": "user",
      "reply": ""
    },
    {
      "user": "請回答",
      "agent": "學生",
      "reply": "這是一道數學題目，讓我們一起來解答吧。根據題目，如果籃子裡原本有15個蘋果，然後你又放進去7個蘋果，這時籃子裡有15 + 7 = 22個蘋果。接著，你拿走4個蘋果，所以籃子裡剩下22 - 4 = 18個蘋果。因此，籃子裡還剩下18個蘋果。"
    },
    {
      "user": "答案正確嗎？",
      "agent": "user",
      "reply": ""
    },
    {
      "user": "答案正確嗎？",
      "agent": "老師",
      "reply": "答案正確！籃子裡最終剩下18個蘋果。你計算得很好，繼續保持這種學習態度！如果還有其他問題或需要更多練習題，隨時告訴我。"
    }
  ],
  "role1_cfg": {
    "name": "老師",
    "backstory": "經驗豐富的數學老師",
    "task": "出題目給小學生練習，不要提供解答，學生回答後確認是否正確"
  },
  "role2_cfg": {
    "name": "學生",
    "backstory": "剛讀小學的學生",
    "task": "思考後回答問題"
  }
}

=== ai_meeting_assistant/knowledge/user_preference.txt ===


=== ai_meeting_assistant/src/.DS_Store ===


=== ai_meeting_assistant/src/.DS_Store ===
[無法讀取此檔案: 'utf-8' codec can't decode byte 0x86 in position 23: invalid start byte]


=== ai_meeting_assistant/src/ai_meeting_assistant/.DS_Store ===


=== ai_meeting_assistant/src/ai_meeting_assistant/.DS_Store ===
[無法讀取此檔案: 'utf-8' codec can't decode byte 0x80 in position 3131: invalid start byte]


=== ai_meeting_assistant/src/ai_meeting_assistant/__init__.py ===


=== ai_meeting_assistant/src/ai_meeting_assistant/crew.py ===
import os
import yaml
from dotenv import load_dotenv

from langchain_openai import ChatOpenAI
from langchain_google_genai import ChatGoogleGenerativeAI
from crewai import Agent, Task, Crew, Process

# 讀取環境變數
load_dotenv()

# ---------- 讀取 YAML ----------
def load_yaml_config(path):
    with open(path, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)

this_dir = os.path.dirname(__file__)
agents_config = load_yaml_config(os.path.join(this_dir, "config/agents.yaml"))

# ---------- 建立 LLM ----------
try:
    openai_llm = ChatOpenAI(
        model="gpt-4o",
        temperature=0.3,
        openai_api_key=os.getenv("OPENAI_API_KEY")
    )
    print("✅ OpenAI LLM 初始化成功")
except Exception as e:
    print(f"❌ OpenAI LLM 初始化失敗: {e}")
    openai_llm = None

try:
    openai_llm_lawyer = ChatOpenAI(
        model="gpt-4o",
        temperature=0.3,
        openai_api_key=os.getenv("OPENAI_API_KEY")
    )
    print("✅ Lawyer OpenAI LLM 初始化成功")
except Exception as e:
    print(f"❌ Lawyer OpenAI LLM 初始化失敗: {e}")
    openai_llm_lawyer = None

try:
    gemini_llm = ChatGoogleGenerativeAI(
        model="gemini-1.5-pro",
        temperature=0.3,
        google_api_key=os.getenv("GOOGLE_API_KEY")
    )
    print("✅ Gemini LLM 初始化成功")
except Exception as e:
    print(f"❌ Gemini LLM 初始化失敗: {e}")
    gemini_llm = None

# ---------- 建立 Agents ----------
agents = {}

if openai_llm:
    accountant_cfg = agents_config["accountant"]
    agents["accountant"] = Agent(
        role=accountant_cfg["role"],
        goal=accountant_cfg["goal"],
        backstory=accountant_cfg["backstory"],
        llm=openai_llm,
        verbose=True
    )
    print("✅ Accountant agent 創建成功")
else:
    print("❌ 無法創建 Accountant agent")

lawyer_cfg = agents_config["lawyer"]
if openai_llm_lawyer:
    agents["lawyer"] = Agent(
        role=lawyer_cfg["role"],
        goal=lawyer_cfg["goal"],
        backstory=lawyer_cfg["backstory"],
        llm=openai_llm_lawyer,
        verbose=True
    )
    print("✅ Lawyer agent (OpenAI) 創建成功")
elif gemini_llm:
    agents["lawyer"] = Agent(
        role=lawyer_cfg["role"],
        goal=lawyer_cfg["goal"],
        backstory=lawyer_cfg["backstory"],
        llm=gemini_llm,
        verbose=True
    )
    print("✅ Lawyer agent (Gemini) 創建成功")
else:
    print("❌ 無法創建 Lawyer agent")

# ---------- 任務流程 ----------
def build_crew(user_question: str, accountant_backstory=None, accountant_task=None,
               lawyer_backstory=None, lawyer_task=None):
    if not agents or "accountant" not in agents or "lawyer" not in agents:
        raise Exception("❌ 需要會計師與律師 agents")

    if accountant_backstory:
        agents["accountant"].config.backstory = accountant_backstory
    if lawyer_backstory:
        agents["lawyer"].config.backstory = lawyer_backstory

    analyze_task = Task(
        description=f"{accountant_task or '請從財務與稅務角度提供建議與風險分析。'}\n\n問題：{user_question}",
        expected_output="詳細的財務分析報告，包含稅務建議和風險評估",
        agent=agents["accountant"]
    )

    legal_task = Task(
        description=f"{lawyer_task or '請從法律角度提供建議與合規分析，並結合財務考量。'}\n\n問題：{user_question}",
        expected_output="完整的法律分析報告，結合財務考量提供綜合建議",
        agent=agents["lawyer"],
        context=[analyze_task]
    )

    crew = Crew(
        agents=[agents["accountant"], agents["lawyer"]],
        tasks=[analyze_task, legal_task],
        process=Process.sequential,
        verbose=True
    )
    return crew, analyze_task, legal_task

def build_custom_crew(user_question: str, role1: dict, role2: dict):
    agent1 = Agent(
        role=role1["name"],
        goal=role1["task"],
        backstory=role1["backstory"],
        llm=openai_llm,
        verbose=True
    )
    agent2 = Agent(
        role=role2["name"],
        goal=role2["task"],
        backstory=role2["backstory"],
        llm=openai_llm_lawyer or openai_llm,
        verbose=True
    )

    task1 = Task(
        description=f"{role1['task']}\n\n問題：{user_question}",
        expected_output="完整分析建議",
        agent=agent1
    )

    task2 = Task(
        description=f"{role2['task']}\n\n問題：{user_question}",
        expected_output="結合第一位角色意見的分析與建議",
        agent=agent2,
        context=[task1]
    )

    crew = Crew(
        agents=[agent1, agent2],
        tasks=[task1, task2],
        process=Process.sequential,
        verbose=True
    )
    return crew, task1, task2

# ---------- 支援文件上下文的記憶型任務 ----------
def build_memory_agent_task(
    user_question: str,
    role_name: str,
    backstory: str,
    task_instruction: str,
    history_log: list,
    llm_instance,
    extra_context: str = ""
):
    history = ""
    for entry in history_log:
        history += f"- 使用者：{entry['user']}\n"
        history += f"  {entry['agent']} 回覆：{entry['reply']}\n"

    agent = Agent(
        role=role_name,
        goal=task_instruction,
        backstory=backstory,
        llm=llm_instance,
        verbose=True
    )

    description = f"""你是 {role_name}，請根據以下歷史對話與使用者的新問題進行回覆：

{history}

以下是使用者提供的輔助文件內容：
{extra_context}

🔎 使用者的新提問：
{user_question}
"""

    task = Task(
        description=description,
        expected_output="請提供專業且有上下文連貫的回應建議",
        agent=agent
    )

    crew = Crew(
        agents=[agent],
        tasks=[task],
        process=Process.sequential,
        verbose=True
    )
    return crew, task


=== ai_meeting_assistant/src/ai_meeting_assistant/app.py ===
import streamlit as st
import os
import json
import sys

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))
from src.ai_meeting_assistant.crew import build_memory_agent_task, openai_llm

st.set_page_config(page_title="AI 輪替式會議助手", layout="wide")
st.title("🧠 AI 輪替式會議助手（含角色、主題記憶與文件分析）")

SAVE_DIR = "./saved_chats"
os.makedirs(SAVE_DIR, exist_ok=True)

# ---------------- 預設角色設定 ----------------
default_role1 = {
    "name": "會計師",
    "backstory": "擁有豐富稅務與財務管理經驗的會計師",
    "task": "從財務與稅務角度提供建議"
}

default_role2 = {
    "name": "律師",
    "backstory": "熟悉商業合規與公司法的律師",
    "task": "從法律角度分析問題並提供建議"
}

# ---------------- 初始化 Session State ----------------
if "meeting_name" not in st.session_state:
    st.session_state.meeting_name = "未命名會議"
if "chat_history" not in st.session_state:
    st.session_state.chat_history = []
if "role1_cfg" not in st.session_state:
    st.session_state.role1_cfg = default_role1.copy()
if "role2_cfg" not in st.session_state:
    st.session_state.role2_cfg = default_role2.copy()

# ---------------- 工具函式 ----------------
def get_output_text(output):
    if hasattr(output, "content"):
        return output.content
    elif isinstance(output, str):
        return output
    elif hasattr(output, "result"):
        return output.result
    return str(output)

def save_chat(meeting_name, chat_history):
    data = {
        "meeting_name": meeting_name,
        "chat_history": [],
        "role1_cfg": st.session_state.role1_cfg,
        "role2_cfg": st.session_state.role2_cfg
    }
    for entry in chat_history:
        clean_entry = dict(entry)
        clean_entry["reply"] = get_output_text(clean_entry["reply"])
        data["chat_history"].append(clean_entry)

    path = os.path.join(SAVE_DIR, f"{meeting_name}.json")
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def load_chat(meeting_name):
    path = os.path.join(SAVE_DIR, f"{meeting_name}.json")
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)

    st.session_state.chat_history = data.get("chat_history", [])
    st.session_state.role1_cfg = data.get("role1_cfg", default_role1.copy())
    st.session_state.role2_cfg = data.get("role2_cfg", default_role2.copy())
    st.session_state.meeting_name = data.get("meeting_name", meeting_name)

def list_saved_meetings():
    return [f[:-5] for f in os.listdir(SAVE_DIR) if f.endswith(".json")]

# ---------------- Sidebar 模式與檔案上傳 ----------------
st.sidebar.header("📁 選擇對話模式")
mode = st.sidebar.radio("請選擇：", ["🆕 開啟新會議", "📂 載入過去會議"])

if mode == "📂 載入過去會議":
    saved = list_saved_meetings()
    selected = st.sidebar.selectbox("選擇過去會議：", saved)
    if st.sidebar.button("📤 載入"):
        load_chat(selected)
        st.success(f"✅ 已載入會議：{selected}")
else:
    if st.sidebar.button("🔄 重置為新會議"):
        st.session_state.meeting_name = "未命名會議"
        st.session_state.chat_history = []
        st.session_state.role1_cfg = default_role1.copy()
        st.session_state.role2_cfg = default_role2.copy()

# 📎 文件上傳
st.sidebar.header("📎 上傳輔助文件")
uploaded_files = st.sidebar.file_uploader(
    "選擇 .pdf, .docx, .xlsx 文件（可複數）",
    type=["pdf", "docx", "xlsx"],
    accept_multiple_files=True
)

uploaded_texts = []
if uploaded_files:
    for file in uploaded_files:
        try:
            if file.name.endswith(".pdf"):
                from PyPDF2 import PdfReader
                reader = PdfReader(file)
                text = "\n".join([page.extract_text() for page in reader.pages])
            elif file.name.endswith(".docx"):
                import docx
                doc = docx.Document(file)
                text = "\n".join([para.text for para in doc.paragraphs])
            elif file.name.endswith(".xlsx"):
                import pandas as pd
                df = pd.read_excel(file)
                text = df.to_markdown()
            else:
                text = f"{file.name} 格式不支援"
            uploaded_texts.append(f"📄 {file.name}:\n{text}")
        except Exception as e:
            uploaded_texts.append(f"⚠️ 無法解析 {file.name}：{e}")

doc_context = "\n\n".join(uploaded_texts)

# ---------------- Header: 主題與儲存 ----------------
st.markdown("### 💼 當前會議主題")
st.session_state.meeting_name = st.text_input("📝 會議主題", value=st.session_state.meeting_name)

col_save, _ = st.columns([1, 5])
with col_save:
    if st.button("💾 儲存目前對話", use_container_width=True):
        save_chat(st.session_state.meeting_name, st.session_state.chat_history)
        st.success(f"✅ 對話已儲存為：「{st.session_state.meeting_name}」")

# ---------------- 角色設定 ----------------
st.subheader("👥 自訂兩位角色")
col1, col2 = st.columns(2)

with col1:
    st.session_state.role1_cfg["name"] = st.text_input("角色 1 名稱", value=st.session_state.role1_cfg["name"])
    st.session_state.role1_cfg["backstory"] = st.text_area("角色 1 背景", value=st.session_state.role1_cfg["backstory"])
    st.session_state.role1_cfg["task"] = st.text_area("角色 1 任務", value=st.session_state.role1_cfg["task"])

with col2:
    st.session_state.role2_cfg["name"] = st.text_input("角色 2 名稱", value=st.session_state.role2_cfg["name"])
    st.session_state.role2_cfg["backstory"] = st.text_area("角色 2 背景", value=st.session_state.role2_cfg["backstory"])
    st.session_state.role2_cfg["task"] = st.text_area("角色 2 任務", value=st.session_state.role2_cfg["task"])

# ---------------- 問題輸入與角色按鈕 ----------------
st.subheader("💬 請輸入您的會議問題：")
user_input = st.text_input("您的問題：", value="")

col_btn1, col_btn2 = st.columns(2)
selected_role = None
role_cfg = None
run_task = False

if col_btn1.button(f"📊 {st.session_state.role1_cfg['name']}回覆", use_container_width=True) and user_input.strip():
    selected_role = st.session_state.role1_cfg["name"]
    role_cfg = st.session_state.role1_cfg
    run_task = True

if col_btn2.button(f"⚖️ {st.session_state.role2_cfg['name']}回覆", use_container_width=True) and user_input.strip():
    selected_role = st.session_state.role2_cfg["name"]
    role_cfg = st.session_state.role2_cfg
    run_task = True

# ---------------- 執行任務 ----------------
if run_task and role_cfg:
    st.session_state.chat_history.append({
        "user": user_input,
        "agent": "user",
        "reply": ""
    })

    with st.spinner(f"{selected_role} 正在分析..."):
        crew, task = build_memory_agent_task(
            user_question=user_input,
            role_name=role_cfg["name"],
            backstory=role_cfg["backstory"],
            task_instruction=role_cfg["task"],
            history_log=st.session_state.chat_history,
            llm_instance=openai_llm,
            extra_context=doc_context
        )
        result = crew.kickoff()
        reply_text = get_output_text(task.output)
        st.success(f"{selected_role} 回覆：\n\n{reply_text}")
        st.session_state.chat_history.append({
            "user": user_input,
            "agent": selected_role,
            "reply": reply_text
        })

# ---------------- 歷史對話 ----------------
st.divider()
st.subheader("🗂️ 歷史對話")
for entry in st.session_state.chat_history:
    if entry["agent"] != "user":
        st.markdown(f"**🧑‍💼 {entry['agent']} 回覆：**\n\n{entry['reply']}")


=== ai_meeting_assistant/src/ai_meeting_assistant/main.py ===
import os
from crew import build_custom_crew

print("🚀 AI 多角色會議助手 CLI 版本")

# 檢查 API 金鑰
openai_key = os.getenv("OPENAI_API_KEY")
google_key = os.getenv("GOOGLE_API_KEY")

if not openai_key:
    print("⚠️  警告：未找到 OPENAI_API_KEY")
if not google_key:
    print("⚠️  警告：未找到 GOOGLE_API_KEY")

# 自訂兩位角色
print("\n👥 請設定第 1 位角色：")
role1_name = input("角色名稱（預設：會計顧問）: ").strip() or "會計顧問"
role1_backstory = input("背景描述（預設：擅長稅務與財務分析）: ").strip() or "擅長稅務與財務分析"
role1_task = input("任務說明（預設：從財務角度提供建議）: ").strip() or "從財務角度提供建議"

print("\n👥 請設定第 2 位角色：")
role2_name = input("角色名稱（預設：法律顧問）: ").strip() or "法律顧問"
role2_backstory = input("背景描述（預設：擅長公司法與合規分析）: ").strip() or "擅長公司法與合規分析"
role2_task = input("任務說明（預設：從法律角度提供建議）: ").strip() or "從法律角度提供建議"

# 啟動互動模式
conversation_history = []

while True:
    print("\n💬 請輸入您的會議問題（輸入 exit 結束）：")
    user_question = input("> ").strip()

    if user_question.lower() == "exit":
        print("\n👋 感謝使用 AI 助手！")
        break

    if not user_question:
        print("⚠️  請輸入非空白的問題。")
        continue

    try:
        print("🧠 建立多角色分析任務...")
        crew, task1, task2 = build_custom_crew(
            user_question=user_question,
            role1={
                "name": role1_name,
                "backstory": role1_backstory,
                "task": role1_task
            },
            role2={
                "name": role2_name,
                "backstory": role2_backstory,
                "task": role2_task
            }
        )

        print("🔍 分析中，請稍候...\n")
        result = crew.kickoff()

        # 儲存紀錄
        conversation_history.append({
            "question": user_question,
            "reply1": task1.output,
            "reply2": task2.output
        })

        print(f"🧑‍💼 {role1_name} 回覆：\n{task1.output}\n")
        print(f"🧑‍💼 {role2_name} 回覆：\n{task2.output}\n")

        # 總結紀錄
        print("📜 對話紀錄：")
        for idx, conv in enumerate(conversation_history, 1):
            print(f"{idx}. 問題：{conv['question']}")
            print(f"   {role1_name}：{conv['reply1'][:60]}...")
            print(f"   {role2_name}：{conv['reply2'][:60]}...\n")

    except Exception as e:
        print("\n❌ 發生錯誤：")
        print(f"錯誤類型：{type(e).__name__}")
        print(f"錯誤訊息：{e}")
        print("💡 檢查 API 金鑰與連線狀態")


=== ai_meeting_assistant/src/ai_meeting_assistant/tools/__init__.py ===


=== ai_meeting_assistant/src/ai_meeting_assistant/tools/web_search_tool.py ===
from langchain_core.tools import BaseTool
from pydantic import BaseModel, Field
from typing import ClassVar
from langchain_community.utilities import GoogleSerperAPIWrapper

class WebSearchInput(BaseModel):
    query: str = Field(..., description="用於查詢的關鍵字")

class WebSearchTool(BaseTool):
    args_schema: ClassVar[type] = WebSearchInput

    def __init__(self):
        super().__init__(
            name="Web Search",
            description="使用 Serper API 執行即時網路搜尋"
        )

    def _run(self, query: str) -> str:
        try:
            search = GoogleSerperAPIWrapper()
            return search.run(query)
        except Exception as e:
            return f"搜尋時發生錯誤：{e}"


=== ai_meeting_assistant/src/ai_meeting_assistant/tools/custom_tool.py ===
from crewai.tools import BaseTool
from typing import Type
from pydantic import BaseModel, Field


class MyCustomToolInput(BaseModel):
    """Input schema for MyCustomTool."""
    argument: str = Field(..., description="Description of the argument.")

class MyCustomTool(BaseTool):
    name: str = "Name of my tool"
    description: str = (
        "Clear description for what this tool is useful for, your agent will need this information to use it."
    )
    args_schema: Type[BaseModel] = MyCustomToolInput

    def _run(self, argument: str) -> str:
        # Implementation goes here
        return "this is an example of a tool output, ignore it and move along."


=== ai_meeting_assistant/src/ai_meeting_assistant/tools/__pycache__/web_search_tool.cpython-311.pyc ===


=== ai_meeting_assistant/src/ai_meeting_assistant/tools/__pycache__/web_search_tool.cpython-311.pyc ===
[無法讀取此檔案: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte]


=== ai_meeting_assistant/src/ai_meeting_assistant/tools/__pycache__/__init__.cpython-311.pyc ===


=== ai_meeting_assistant/src/ai_meeting_assistant/tools/__pycache__/__init__.cpython-311.pyc ===
[無法讀取此檔案: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte]


=== ai_meeting_assistant/src/ai_meeting_assistant/config/agents.yaml ===
accountant:
  role: 會計師
  goal: 提供財務與稅務建議
  backstory: 擁有多年企業財務經驗的專業會計師，專精於稅務規劃與財務分析。

lawyer:
  role: 律師
  goal: 提供法律建議與合規分析
  backstory: 熟悉公司法與商業法律的律師，專注於企業合規與風險管理。


=== ai_meeting_assistant/src/ai_meeting_assistant/config/tasks.yaml ===
analyze_from_accounting:
  description: >
    使用者輸入的問題是：
    {user_question}

    你是一位會計師，請從財務與稅務角度提供建議與風險分析。
  expected_output: >
    詳細建議與說明
  agent: accountant


=== ai_meeting_assistant/src/ai_meeting_assistant/__pycache__/main.cpython-311.pyc ===


=== ai_meeting_assistant/src/ai_meeting_assistant/__pycache__/main.cpython-311.pyc ===
[無法讀取此檔案: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte]


=== ai_meeting_assistant/src/ai_meeting_assistant/__pycache__/crew.cpython-311.pyc ===


=== ai_meeting_assistant/src/ai_meeting_assistant/__pycache__/crew.cpython-311.pyc ===
[無法讀取此檔案: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte]


=== ai_meeting_assistant/src/ai_meeting_assistant/__pycache__/__init__.cpython-311.pyc ===


=== ai_meeting_assistant/src/ai_meeting_assistant/__pycache__/__init__.cpython-311.pyc ===
[無法讀取此檔案: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte]
